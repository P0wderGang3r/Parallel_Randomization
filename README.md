# Parallel_Randomization

У нас есть четыре переменные, которые задаются в рамках самого 
"конгруэнтного метода формирования псевдослучайных чисел":

	Мультипликатор зерна A
		Множитель для создания эффекта случайности
		Обычно - сокрыт от пользователя
	Сдвиг зерна B
		Сдвиг для создания эффекта большей случайности
		Обычно - сокрыт от пользователя
	Остаток от деления результата С
		Для получения числа в рамках от 0 до C
		Обычно - применяется пользователем как rand() % C
	Зерно генерации seed
		Первый элемент, задающий цепочку для генерации последовательности "случайностей"
		Обычно - сокрыт от пользователя
			Либо привязан ко времени системы
			Либо открыт для пользователя, как, например, в майнкрафте

Также мы имеем формулу генерации следующего числа (однопоточная):

	y(n+1) = (A * y(n) + B) mod C
	Здесь y(n+1) - текущий элемент, y(n) - предыдущий элемент, остальное понятно

Для независимости результатов генерации от округления лучше эту формулу изменить.

	Для этого сделаем фиксированное C, равное предельному значению в типе unsigned.
		(этот метод работает только для целых беззнаковых чисел)
		(оставляем C мы для того, чтобы результат не выходил за пределы типа unsigned int)

Также введём понятие рамок числа, которое и будем вставлять в массив:

	Пусть это число будет в пределах [min, max]
	Запишем формулу такого деления с остатком, чтобы число попадало в эти рамки:
		#define bounds (max - min + 1) + min
	
Тогда изменим алгоритм на данный (по сути это то, что требует Чусов с точки зрения формулы вычисления):

	Получение следующего зерна генерации элемента:
		seedI = (A * seedI + B) mod C
	Запись значения в массив, с которым мы работаем:
		y(n+1) = seed(n+1) mod bounds
		или
		y(n+1) = seed(n+1) mod (max - min + 1) + min
			Если подставить bounds через define

Применяем этот алгоритм, пока есть неназначенные элементы в массиве, и на этом заканчиваем заполнение.

A, B, mod заранее определены преподавателем, поэтому их нужно будет просто скопировать.
